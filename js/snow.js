if (navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)) {   // 如果是移动设备，则不显示雪花效果 } else {   // 如果是非移动设备，则创建雪花效果的canvas元素   // document.write('<canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:-2;pointer-events:none"></canvas>');    // 定义雪花效果的参数   window && (() => {     let e = {       flakeCount: 50, // 雪花数目       minDist: 150,   // 最小距离       color: "255, 255, 255", // 雪花颜色       size: 1.5,  // 雪花大小       speed: .5,  // 雪花速度       opacity: .7,    // 雪花透明度       stepsize: .5    // 步距     };      // 获取requestAnimationFrame函数     const t = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {       window.setTimeout(e, 1e3 / 60)     };      window.requestAnimationFrame = t;      // 获取canvas元素和2D绘图上下文     const i = document.getElementById("snow"),       n = i.getContext("2d"),       o = e.flakeCount;      let a = -100,       d = -100,       s = [];      // 设置canvas的宽度和高度为窗口的宽度和高度     i.width = window.innerWidth;     i.height = window.innerHeight;      // 绘制雪花效果的函数     const h = () => {       // 清除画布       n.clearRect(0, 0, i.width, i.height);        const r = e.minDist;        // 遍历雪花数组       for (let t = 0; t < o; t++) {         let o = s[t];         const h = a,           w = d,           m = o.x,           c = o.y,           p = Math.sqrt((h - m) * (h - m) + (w - c) * (w - c));          if (p < r) {           const e = (h - m) / p,             t = (w - c) / p,             i = r / (p * p) / 2;            // 根据距离调整速度           o.velX -= i * e;           o.velY -= i * t;         } else {           // 减小速度           o.velX *= .98;            // 限制速度增加的上限           if (o.velY < o.speed && o.speed - o.velY > .01) {             o.velY += .01 * (o.speed - o.velY);           }            // 根据步数调整水平速度           o.velX += Math.cos(o.step += .05) * o.stepSize;         }          // 设置雪花的颜色和透明度         n.fillStyle = "rgba(" + e.color + ", " + o.opacity + ")";          // 更新雪花的位置         o.y += o.velY;         o.x += o.velX;          // 如果雪花超出画布范围，则重新生成雪花         if (o.y >= i.height || o.y <= 0) {           l(o);         }          if (o.x >= i.width || o.x <= 0) {           l(o);         }          // 绘制雪花         n.beginPath();         n.arc(o.x, o.y, o.size, 0, 2 * Math.PI);         n.fill();       }        // 循环调用h函数，实现动画效果       t(h);     };      // 生成新的雪花     const l = e => {       e.x = Math.floor(Math.random() * i.width);       e.y = 0;       e.size = 3 * Math.random() + 2;       e.speed = 1 * Math.random() + .5;       e.velY = e.speed;       e.velX = 0;       e.opacity = .5 * Math.random() + .3;     };      // 监听鼠标移动事件，更新鼠标坐标     document.addEventListener("mousemove", (e => {       a = e.clientX;       d = e.clientY;     }));      // 监听窗口大小改变事件，更新canvas的宽度和高度     window.addEventListener("resize", (() => {       i.width = window.innerWidth;       i.height = window.innerHeight;     }));      // 初始化雪花效果     (() => {       for (let t = 0; t < o; t++) {         const t = Math.floor(Math.random() * i.width),           n = Math.floor(Math.random() * i.height),           o = 3 * Math.random() + e.size,           a = 1 * Math.random() + e.speed,           d = .5 * Math.random() + e.opacity;          // 生成雪花对象并添加到数组中         s.push({           speed: a,           velX: 0,           velY: a,           x: t,           y: n,           size: o,           stepSize: Math.random() / 30 * e.stepsize,           step: 0,           angle: 180,           opacity: d         });       }        // 开始绘制雪花效果       h();     })();   })(); }